# **01. 요구사항 확인**

## **(1) 소프트웨어 생명 주기**
---
### **소프트웨어 생명 주기(Software Life Cycle)**

- **소프트웨어를 개발하기 위한** 설계, 운용, 유지보수 등의 **과정을 각 단계별로 나눈 것**
- 소프트웨어 생명 주기는 소프트웨어 개발 단계와 각 단계별 주요 활동, 그리고 활동의 결과에 대한 산출물로 표현
- 대표적인 생명 주기 모형
1) 폭포수 모형
2) 프로토타입 모형
3) 나선형 모형
4) 애자일 모형

### **폭포수 모형(Waterfall Model)**

- 이전 단계로 돌아갈 수 없다는 전제하에 **각 단계를 확실히 매듭짓고** 그 **결과**를 철저하게 **검토하여 승인 과정을 거친 후에 다음 단계를 진행하는 개발 방법론**
- 가장 오래되고 폭넓게 사용된 전통적인 소프트웨어 생명 주기 모형
- 고전적 생명 주기 모형
- 모형을 적용한 경험과 성공 사례가 많음
- 각 단계가 끝난 후에는 다음 단계를 수행하기 위한 결과물이 명확하게 산출되어야 함

### **프로토타입 모형(Prototype Model, 원형 모형)**

- 사용자의 요구사항을 파악하기 위해 **실제 개발될 소프트웨어**에 대한 **견본품(Prototype)을 만들어 최종 결과물을 예측**하는 모형
- 견본품은 사용자와 시스템 사이의 인터페이스에 중점을 두어 개발

### **나선형 모형(Spiral Model, 점진적 모형)**

- 나선을 따라 돌듯이 **여러 번의 소프트웨어 개발 과정을 거쳐 점진적**으로 완벽한 최종 소프트웨어를 **개발하는 모형**
- 보헴(Barry Boehm)이 제안
- 폭포수 모형과 프로토 타입 모형의 장점에 위험 분석 기능을 추가한 모형
- 누락되거나 추가된 요구사항을 첨가할 수 있음
- 유지보수 과정 필요 X
- 4가지 주요 활동 **(계획/분석/개발/평가)**
    - **계획** 수립 > 위험 **분석** > **개발** 및 검증 > 고객 **평가**
 
 ### **애자일 모형(Agile Model)**

- 애자일은 '민첩한', '기민한' 이라는 의미
- 고객의 **요구사항 변화에 유연하게 대응할 수 있도록 일정한 주기를 반복하면서 개발하는 모형**
- 어느 특정 개발 방법론이 아니라 좋은 것을 빠르고 낭비 없게 만들기 위해 고객과의 소통에 초점을 맞춘 방법론을 통칭
- 폭포수 모형(Waterfall Model)과 대조적
- 기업 활동 전반에 걸쳐 사용
- 대표적인 개발 모형
    - 스크럼(Scrum)
    - XP(eXtreme Programming)
    - 칸반(Kanban)
    - Lean
    - 기능 중심 개발(FDD: Feature Driven Development)

### **애자일 개발 4가지 핵심 가치**

- 프로세스와 도구보다는 개인과 상호작용에 더 가치를 둠
- 방대한 문서보다는 실행되는 SW에 더 가치를 둠
- 계약 협상보다는 고객과 협업에 더 가치를 둠
- 계획을 따르기 보다 변화에 반응하는 것에 더 가치를 둠

### **소프트웨어 공학(Software Engineering)**

- 소프트웨어 공학(SE: Software Engineering)은 **소프트웨어의 위기를 극복하기 위한 방안으로 연구된 학문**
- 여러 가지 방법론과 도구, 관리 기법들을 통하여 소프트웨어의 품질과 생산성 향상을 목적으로 함
- 소프트웨어 공학의 기본 원칙
    - 현대적인 프로그래밍 기술을 계속적으로 적용해야 함
    - 개발된 소프트웨어의 품질이 유지되도록 지속적으로 검증해야 함
    - 소프트웨어 개발 관련 사항 및 결과에 대한 명확한 기록을 유지해야 함
<br><br>
---

## **(2) 스크럼(Scrum) 기법**

---

### **스크럼(Scrum)**

- 팀이 중심이 되어 개발의 효율성을 높이는 기법
- 팀원 스스로가 스크럼 팀을 구성하고, 개발 작업에 관한 모든 것을 스스로 해결할 수 있어야 함

|구성원|역할|
|:---:|---|
|**제품 책임자<br>(PO: Product Owner)**| - 요구사항이 담긴 **백로그(Backlog)** 를 작성하는 주체<br>- 이해관계자들 중 개발될 제품에 대한 이해도가 높고, 요구사항을 책임지고 의사를 결정할 사람으로 선정|
|**스크럼 마스터<br>(SM: Scrum Master)**| - 스크럼 팀이 스크럼을 잘 수행할 수 있도록 가이드 역할을 수행
|**개발 팀<br>(DT: Development Team)**| - 제품 책임자와 스크럼 마스터를 제외한 모든 팀원으로 제품 개발을 수행

__* 백로그(Backlog)__ : 제품 개발에 필요한 요구사항을 모두 모아 우선순위를 부여해 놓은 목록<br>
__* 이해관계자(Stakeholder)__ : 소프트웨어 개발과 관련해서 이해관계자는 소프트웨어 개발의뢰자/개발자/사용자 등

### **스크럼 개발 프로세스**
|프로세스|내용|
|:---:|---|
|**스프린트 계획 회의<br>(Sprint Planning Meeting)**|**제품 백로그** 중 이번 스프린트에서 수행할 작업을 대상으로 단기 일정을 수립하는 회의|
|**스프린트<br>(Sprint)**|실제 개발 작업을 진행하는 과정으로, 보통 2~4주 정도의 기간 내에서 진행함|
|**일일 스크럼 회의<br>(Daily Scrum Meeting)**|모든 팀원이 매일 약속된 시간에 약 15분 동안 진행 상황을 점검하는 회의<br>남은 작업 시간은 **소멸 차트(Burn-down Chart)**에 표시함|
|**스프린트 검토 회의<br>(Sprint Review)**|부분 또는 전체 완성 제품이 요구사항에 잘 부합하는지 테스팅하는 회의|
|**스프린트 회고<br>(Sprint Retropective)**|정해놓은 규칙 준수 여부 및 개선할 점을 확인하고 기록하는 것|

__* 제품 백로그(Product Backlog)__ : 제품 개발에 필요한 모든 요구사항(User Story)을 우선순위에 따라 나열한 목록으로, 개발 과정에서 새롭게 도출되는 요구사항으로 인해 계속 업데이트 됨. 제품 백로그에 작성된 사용자 스토리는 전체 일정 계획인 릴리즈 계획(Release Plan)을 수립할 때 사용.<br>
__* 소멸 차트(Burn-down Chart)__ : 해당 스프린트에서 작업의 진행 상황을 확인할 수 있도록 시간의 경과에 따라 남은 작업 시간을 그래프로 표현한 것. 초기에 추정했던 전체 작업 시간은 작업이 진행될 수록 점점 줄어(Burn-down)들게 됨.
<br><br>
※ 스크럼 개발을 진행할 때는 "**계획**하여 **진행(스프린트)** 한 후 **회의**와 **검토**를 거쳐 **회고**한다.<br><br>

---

## **XP(eXtreme Programming) 기법**
---
### **XP(eXtreme Programming)**
- 수시로 발생하는 고객의 요구사항에 **유연하게 대응**하기 위해 고객의 참여와 개발 과정의 반복을 극대화하여 개발 생산성을 높이는 방법.
- 짧고 반복적인 개발 주기, 단순한 설계, 고객의 적극적인 참여를 통해 소프트웨어를 빠르게 개발하는 것을 목적으로 함.
- 릴리즈의 기간을 짧게 반복하면서 고객의 요구사항 반영에 대한 가시성을 높임.
- **XP의 5대 핵심 가치**
    - **의사소통(Communication)**
    - **단순성(Simplicity)**
    - **용기(Courage)**
    - **존중(Respect)**
    - **피드백(Feedback)**
    
<br>

### **XP 개발 프로세스**

|프로세스|내용|
|:---:|:---|
|**릴리즈 계획 수립<br>(Release Planning)**|- 부분 혹은 전체 개발 완료 시점에 대한 일정을 수립하는 것<br>- 몇 개의 스토리가 적용되어 부분적으로 기능이 완료된 제품을 제공하는 것을 **릴리즈**라고 함.|
|**이터레이션<br>(Iteration, 주기)**|실제 개발 작업을 진행하는 과정으로 보통 1~3주 정도의 기간으로 진행됨.|
|**승인 검사<br>(Acceptance Test, 인수 테스트)**|하나의 이터레이션 안에서 부분 완료 제품이 구현되면 수행하는 테스트|
|**소규모 릴리즈(Small Release)**|요구사항에 유연하게 대응할 수 있도록 릴리즈의 규모를 축소한 것|

<br>

※ "**계획**하고 **진행(이터레이션)** 한 후 **검사** 하고 **출시(릴리즈)** 한다."
<br><br>

### **XP의 주요 실천 방법(Practice)**

|실천 방법|내용|
|:---:|:---|
|**Pair Programming<br>(짝 프로그래밍)**|다른 사람과 함께 프로그래밍을 수행함으로써 개발에 대한 책임을 공동으로 나눠 갖는 환경을 조성함.|
|**Collective Ownership<br>(공동 코드 소유)**|개발 코드에 대한 권한과 책임을 공동으로 소유함.|
|**Test-Driven Development<br>(테스트 주도 개발)**|- 개발자가 실제 코드를 작성하기 전에 테스트 케이스를 먼저 작성하므로 자신이 무엇을 해야할지를 정확히 파악함.<br>- 테스트가 지속적으로 진행될 수 있도록 자동화된 테스팅 도구(구조, 프레임워크)를 사용함.|
|**Whole Team<br>(전체 팀)**|개발에 참여하는 모든 구성원(고객 포함)들은 각자 자신의 역할이 있고 그 역할에 대한 책임을 가져야 함.|
|**Continuous Integration<br>(계속적인 통합)**|모듈 단위로 나눠서 개발된 코드들은 하나의 작업이 마무리 될 때마다 지속적으로 통합됨.|
|**Refactoring<br>(리팩토링)**|- 프로그램 기능의 변경 없이 시스템을 재구성함.<br>- **목적** : 프로그램을 쉽게 이해하고 쉽게 수정하여 빠르게 개발할 수 있도록 하기 위함.|
|**Small Release<br>(소규모 릴리즈)**|릴리즈 기간을 짧게 반복함으로써 고객의 요구 변화에 신속히 대응할 수 있음.|

<br>

※ 영문으로도 알고 있어야 하며, 각각의 의미는 서로 구분할 수 있을 정도면 됨.

<br><br>

## **(4) 현행 시스템 파악**

---
### **현행 시스템 파악 절차**

- 1단계
    - 시스템 구성 파악 : 조직의 주요 업무를 담당하는 **기간 업무**와 이를 지원하는 **지원 업무**로 구분하여 기술 함.
    - 시스템 기능 파악 : 현재 제공하는 기능들을 **주요 기능**과 **하부 기능**, **세부 기능**으로 구분하여 `계층형`으로 표시함.
    - 시스템 인터페이스 파악 : 단위 업무 시스템 간에 주고받는 데이터의 **종류, 형식, 프로토콜, 연계 유형, 주기** 등을 명시함.
- 2단계
    - 아키텍쳐 구성 파악 : 최상위 수준에서 계층별로 표현한 **아키텍쳐 구성도**를 작성함.
    - 소프트웨어 구성 파악 : 소프트웨어들의 *제품명, 용도, 라이선스 적용 방식, 라이선스 수* 등을 명시함.
- 3단계
    - 하드웨어 구성 파악 : 단위 업무 시스템들이 운용되는 서버의 주요 **사양**과 **수량**, 그리고 **서버의 이중화 적용 여부**를 명시함.
    - 네트워크 구성 파악 : 서버의 위치, 서버 간의 네트워크 연결 방식을 **네트워크 구성도**로 작성함.

<br><br>

## **(5) 개발 기술 환경 파악**
---
### **개발 기술 환경 파악의 개요**

개발하고자 하는 소프트웨어와 관련된 **운영체제(OS)**, **데이터베이스 관리 시스템(DBMS)**, **미들웨어** 등을 선정할 때 고려해야 할 사항을 기술하고, **오픈 소스**를 사용할 때 주의해야 할 내용을 제시한다.

<br><br>

### **운영체제(OS, Operating System)**

- 운영체제는 `컴퓨터 시스템의 자원을 효율적으로 관리`하며, 사용자가 `컴퓨터를 편리하고 효율적으로 사용할 수 있도록 환경을 제공하는 소프트웨어`.
- 컴퓨터 사용자와 컴퓨터 하드웨어 간의 인터페이스로서 동작하는 시스템 소프트웨어의 일종.
- 다른 응용 프로그램이 유용한 작업을 할 수 있도록 환경을 제공.
- **운영체제 관련 요구사항 식별 시 고려사항**
    - 가용성
    - 성능
    - 기술 지원
    - 주변 기기
    - 구축 비용